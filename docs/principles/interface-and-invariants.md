# 接口与不变量

## 定义

**接口（Interface）**：系统与外界交互的边界，定义了"可以做什么"。

**不变量（Invariant）**：系统必须始终保持的性质，定义了"什么必须成立"。

## 为什么重要

在 AI 时代，我们可以快速生成实现，但如果不明确接口与不变量，我们就无法：

- 判断实现是否正确
- 验证重构是否安全
- 诊断系统为什么失败

## 跨领域例子

### 例子 1: 文件系统

**接口**：
```
read(fd, buf, size) -> bytes_read
write(fd, buf, size) -> bytes_written
fsync(fd) -> success/failure
```

**关键不变量**：
1. **崩溃一致性**：如果 `fsync()` 返回成功，那么即使系统崩溃，数据也不会丢失
2. **原子性**：`write()` 要么完全成功，要么完全失败，不会出现部分写入
3. **顺序性**：如果 A 在 B 之前调用 `fsync()`，那么 A 的数据一定在 B 之前持久化

**如何验证**：
- 单元测试：测试正常的读写操作
- 故障注入：在 `fsync()` 后立即模拟崩溃，检查数据是否丢失
- 属性测试：生成随机的读写序列，验证顺序性

### 例子 2: 数据库事务

**接口**：
```
begin_tx() -> tx_id
read(tx_id, key) -> value
write(tx_id, key, value) -> success/failure
commit(tx_id) -> success/failure
abort(tx_id) -> success
```

**关键不变量**：
1. **原子性（Atomicity）**：事务要么全部提交，要么全部回滚
2. **隔离性（Isolation）**：并发事务不会看到彼此的中间状态
3. **一致性（Consistency）**：事务保持数据库约束（如外键、唯一性）
4. **持久性（Durability）**：提交的事务不会因崩溃而丢失

**如何验证**：
- 单元测试：测试单个事务的提交与回滚
- 并发测试：测试多个事务并发执行时的隔离性
- Jepsen 风格测试：在网络分区、节点崩溃等场景下验证 ACID 性质

### 例子 3: 网络协议（TCP）

**接口**：
```
connect(addr) -> socket
send(socket, data) -> bytes_sent
recv(socket, buf, size) -> bytes_received
close(socket) -> success
```

**关键不变量**：
1. **可靠性**：发送的数据要么全部到达，要么连接失败
2. **有序性**：接收方收到的数据顺序与发送方发送的顺序一致
3. **流控制**：发送方不会压垮接收方
4. **拥塞控制**：发送方不会压垮网络

**如何验证**：
- 单元测试：测试正常的连接、发送、接收
- 网络模拟：模拟丢包、延迟、乱序，验证可靠性与有序性
- 压力测试：测试流控制与拥塞控制

## 如何识别不变量

在设计系统时，问自己以下问题：

1. **安全性（Safety）**：什么事情"永远不会"发生？
   - 例如：两个进程永远不会同时持有同一个锁
   - 例如：已提交的事务永远不会丢失

2. **活性（Liveness）**：什么事情"最终会"发生？
   - 例如：如果网络正常，消息最终会到达
   - 例如：如果没有死锁，事务最终会提交或回滚

3. **单调性（Monotonicity）**：什么事情"只会增加不会减少"？
   - 例如：日志的长度只会增加
   - 例如：版本号只会递增

## 如何验证不变量

### 方法 1: 单元测试

测试正常情况下不变量是否成立。

```python
def test_file_write_atomicity():
    fd = open("test.txt", "w")
    write(fd, "hello")
    # 不变量：写入后立即读取应该返回相同内容
    assert read(fd) == "hello"
```

### 方法 2: 属性测试

生成随机输入，验证不变量在所有情况下都成立。

```python
@given(st.lists(st.text()))
def test_file_write_order(writes):
    fd = open("test.txt", "w")
    for data in writes:
        write(fd, data)
    # 不变量：读取的顺序应该与写入的顺序一致
    assert read_all(fd) == "".join(writes)
```

### 方法 3: 故障注入

模拟失败场景，验证不变量是否仍然成立。

```python
def test_file_crash_consistency():
    fd = open("test.txt", "w")
    write(fd, "hello")
    fsync(fd)
    # 模拟崩溃
    simulate_crash()
    # 不变量：fsync 后崩溃，数据不应该丢失
    assert read("test.txt") == "hello"
```

## 常见陷阱

### 陷阱 1: 混淆接口与实现

**错误**：把实现细节当成不变量。

例如："哈希表必须使用链表法解决冲突"——这是实现细节，不是不变量。

**正确**：不变量应该是抽象的性质。

例如："查找操作的平均时间复杂度是 O(1)"——这是不变量。

### 陷阱 2: 不变量过于宽松

**错误**："系统在大多数情况下是正确的"——这不是不变量。

**正确**："系统在所有情况下都满足 X 性质"——这才是不变量。

### 陷阱 3: 不变量无法验证

**错误**："系统是高性能的"——这太模糊，无法验证。

**正确**："99% 的请求延迟小于 10ms"——这可以用基准测试验证。

## 总结

- **接口**定义了"可以做什么"
- **不变量**定义了"什么必须成立"
- 识别不变量的关键是问"什么永远不会发生"和"什么最终会发生"
- 验证不变量需要单元测试、属性测试、故障注入的组合

---

下一步：阅读 [失败模型](./failure-model.md) 了解如何识别失败场景。
