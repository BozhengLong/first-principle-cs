# CLAUDE.md

## 项目概述

first-principles-cs 是一个 AI 时代的第一性原理计算机科学课程体系。目标不是"教人写代码"，而是通过从零构建 8 个核心系统，让学习者真正理解计算机科学的基础设施是如何被搭建起来的。

## 项目的双重使命

这个项目同时在做两件事：

1. **对计算机科学的第一性原理解读** — 不是教 API 用法，而是从零构建核心系统，理解"为什么这样设计"
2. **对学习和教育本身的第一性原理思考** — 不是套用传统教学模式，而是追问"人到底是怎么学会东西的？什么样的体验才能真正产生理解？"

第二点是这个项目区别于所有其他 CS 教程的根本。我们不只是在教 CS，更是在探索"教"和"学"本身应该是什么样的。

## 产品愿景

这不只是一个开源代码仓库，而是一个**学习产品**。核心转变：

### 核心转变：从"给答案"到"提问题"

| 传统方式 | 我们的方式 |
|---------|-----------|
| 完整代码，被动阅读 | 骨架代码，主动填充 |
| 技术文档风格 | 引导式学习指南 |
| 一次性呈现 | 渐进式挑战 |
| 只有最终测试 | 每步都有验证 |

### 认知科学基础

产品设计的每个决策都有认知科学依据：

| 原理 | 含义 | 在产品中的体现 |
|------|------|---------------|
| **主动学习** | 学习者必须"做"，不能只"看" | 骨架代码，主动填充 |
| **测试效应** | 测试本身就是学习过程 | 每步都有即时反馈 + 诊断 |
| **生成效应** | 自己想出的答案记得更牢 | 苏格拉底式引导，不直接给答案 |
| **认知负荷** | 工作记忆有限，一次只能处理少量信息 | 极小步骤（每步 < 5 分钟） |
| **具体→抽象** | 先例子后原理，不是反过来 | 始终从具体例子开始 |
| **间隔重复** | 知识需要在不同时间多次巩固 | 复习机制 + 跨项目概念重现 |

### 理想学习流程（POE 模式）

```
1. 激发好奇心 → "猜猜这段代码的结果？"
2. 制造认知冲突 → 猜错了，引发思考
3. 引导式探索 → 苏格拉底式提问，不直接给答案
4. 动手验证 → 填入缺失的代码
5. 即时反馈 + 诊断 → 测试通过 + 解释为什么
6. 迁移应用 → 用学到的概念解决新问题
7. 间隔复习 → 强化记忆
```

### 有效思考 vs 无效思考

不是"减少思考"，而是**消除无效思考、保留并强化有效思考**。

| 无效思考（应该消除） | 有效思考（应该保留甚至强化） |
|---------------------|---------------------------|
| "这个语法是什么意思？" | "这个问题应该怎么分解？" |
| "为什么报错了？" | "这两种方案哪个更好？为什么？" |
| "环境怎么配置？" | "如果这里失败了会怎样？" |

产品设计的目标：把学习者的脑力从语法困惑、报错排查、环境配置中解放出来，全部投入到问题分解、方案权衡、失败推理这些真正有价值的思考中。

### 模糊性的引入时机

不是"永远清晰"，而是**在正确的时机引入模糊**：

- **学习初期** → 极致清晰：每一步都明确，消除一切不必要的困惑
- **学习中期** → 引入适度模糊：给出不完整的信息，培养判断力
- **学习后期** → 拥抱模糊：面对开放问题，学会在不确定中做决策

### 宏观-中观-微观自由穿梭

学习者应能在三个层次之间自由导航，而不是被锁在线性路径里：

| 层次 | 关注点 | 例子 |
|------|--------|------|
| **宏观** | 系统架构，组件如何协作 | "解释器由哪几部分组成？数据怎么流动？" |
| **中观** | 组件设计，接口与权衡 | "为什么环境用链表而不是哈希表？" |
| **微观** | 实现细节，具体代码 | "这个递归求值函数怎么处理闭包？" |

理想体验：在任何一个层次遇到困惑时，可以随时"放大"到细节或"缩小"到全局，理解当前代码在整个系统中的位置和意义。

### 小白痛点的深层结构

小白的问题不是"不够聪明"，而是**心理障碍**。痛点有层次结构：

```
                    ┌─────────────────┐
                    │   身份认同障碍   │  "我不是那种人"
                    │   （最深层）     │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
     ┌────────▼────────┐ ┌──▼───────┐ ┌────▼────────┐
     │   能力焦虑      │ │ 选择瘫痪 │ │  社交恐惧   │
     │ "我学不会"     │ │ "从哪开始"│ │ "问问题丢人"│
     └────────┬────────┘ └────┬─────┘ └──────┬──────┘
              │               │              │
     ┌────────▼────────┐ ┌────▼─────┐ ┌──────▼──────┐
     │   符号恐惧      │ │ 信息过载 │ │  孤独感     │
     │ "代码像天书"   │ │ "太多了" │ │ "没人帮我"  │
     └─────────────────┘ └──────────┘ └─────────────┘
```

**每个痛点的解法：**

| 痛点 | 表现 | 解法 |
|------|------|------|
| 身份认同 | "编程是聪明人才能做的" | 展示非典型成功案例；重新定义编程（像学开车） |
| 能力焦虑 | "太难了，我学不会" | 极小步骤（每步 < 5 分钟）；只和昨天的自己比 |
| 选择瘫痪 | "Python 还是 JavaScript？" | 不给选择，直接开始；预设好一切 |
| 符号恐惧 | "代码看起来像乱码" | 从自然语言开始逐步替换；符号翻译卡 |
| 信息过载 | "要学的太多了" | 严格控制每步信息量；隐藏不需要的复杂度 |
| 孤独感 | "遇到问题不知道问谁" | AI 助教（永远不嘲笑你）；展示"大家都卡住过" |

**核心洞察：** 最有效的干预不是"教更多"，而是**"减少恐惧"**。第一分钟的成功体验比任何教程都重要。

### 交互性与可视化的极致愿景

不只是"缺少可视化"，而是要做到**概念可触摸、可操作、可拖拽组合**：

- **概念可视化** — 环境链、调用栈、内存分配不是抽象描述，而是可以看到、可以操作的动态图
- **过程可回放** — 代码执行的每一步都可以前进、后退、暂停，像调试器但面向学习
- **失败可体验** — 不是告诉你"死锁是什么"，而是让你在模拟中亲眼看到两个进程卡住
- **抽象可触摸** — 闭包不是"捕获环境的函数"，而是"看，这个函数记住了它出生的地方"

### 未来学习的六大核心特征

| # | 从 | 到 | 说明 |
|---|----|----|------|
| 1 | 写代码 | 操作概念 | 代码是手段不是目的；概念可以被可视化、可触摸、可操作 |
| 2 | 被动接收 | 主动探索 | 不是"教你 X"，而是"你想知道什么？"学习者驱动，AI 辅助 |
| 3 | 线性路径 | 按需深入 | 不是"必须学完 A 才能学 B"，而是"你需要多深就学多深" |
| 4 | 抽象理论 | 具体体验 | 不是"闭包是捕获环境的函数"，而是"看，这个函数记住了它出生的地方" |
| 5 | 独自学习 | AI 陪伴 | AI 不是替代老师，而是永远有耐心、永远不嘲笑你的学习伙伴 |
| 6 | 一次学会 | 持续强化 | 间隔重复；在不同场景中重新遇到同一概念 |

理解计算机分三层：使用者 → 构建者 → 创新者。本项目目标是培养**构建者**和**创新者**。

### 学习形式演变时间线

| 时期 | 输入 | 练习 | 反馈 | 痛点/特点 |
|------|------|------|------|-----------|
| **过去**（2000-2020） | 教科书、视频课程 | 写代码、做题 | 编译器报错、考试成绩 | 反馈慢、抽象、孤独 |
| **现在**（2020-2025） | 交互式教程 | 在线编程环境 | 即时测试结果 | 仍需写代码、仍然抽象 |
| **近未来**（2025-2030） | AI 导师 + 可视化模拟 | 自然语言描述 + 概念操作 | AI 诊断 + 个性化建议 | 几乎不需要写代码，但需理解概念 |
| **远未来**（2030+） | 沉浸式体验（VR/AR） | 直接操作抽象概念 | 实时可视化 + 触觉反馈 | 学习 = 体验，概念 = 可触摸的对象 |

### 当前已实现 vs 差距

tiny-interpreter 的 `learn/` 目录是第一个实验（骨架代码 + 分级提示 + 顿悟设计）。已知差距：
- 缺少真正的交互式体验（playground 只是演示脚本）
- 缺少错误诊断系统（犯错时只有测试失败，没有针对性提示）
- 缺少可视化执行（环境链变化过程）
- 缺少间隔复习机制
- 各模块的"顿悟设计"深度不均匀
- 当前是纯 Markdown + 代码仓库，目标是交互式 Web 应用
- 缺少 AI 引导的 prompt 库
- 缺少 BYOK AI 集成

## 产品架构

产品愿景描述了"为什么"和"学什么"，这一节描述**"怎么做"**——把学习理念变成可用的产品。

### 统一产品：四种体验的融合

不是四个独立产品，而是**一个统一 Web 应用中的四个体验阶段**。学习者的自然流转路径：

| 阶段 | 体验 | 做什么 | 触发时机 |
|------|------|--------|---------|
| 1 | **逆向学习**（入口） | 先给能跑的系统，让学习者玩 | 进入任何项目的第一步 |
| 2 | **对话式学习** | AI 引导思考"猜猜改这里会怎样？" | 好奇心被激发后 |
| 3 | **概念操场** | 拖拽 AST 节点、操作环境链 | 需要深入理解某个概念时 |
| 4 | **模拟沙盒** | 故意制造故障（栈溢出、死锁） | 探索边界和失败场景时 |

四种体验不是线性的，学习者可以随时在它们之间自由切换。

### AI 引导的三层架构

| 层 | 形式 | 是否需要 API | 触发方式 |
|----|------|-------------|---------|
| **内联提示** | 代码/可视化旁的小气泡 | 不需要 | 自动出现在关键位置 |
| **引导面板** | 底部可收起面板 | 不需要 | 学习者点击提示后展开 |
| **深度对话** | 完整 AI 聊天 | 需要 BYOK | 学习者主动发起 |

核心原则：
- 前两层覆盖 **80% 的引导需求**，完全免费，不需要任何 API key
- AI 不是独立聊天窗口，而是**"长"在学习内容上的**——提示出现在学习者可能卡住的精确位置
- 没有 API key 也能获得完整的引导式学习体验，有 key 则体验更深

### BYOK 多提供商设计

用户填写自己的 base URL + API key，统一适配层对接各家 API：

| 提供商 | 备注 |
|--------|------|
| OpenAI | GPT-4o, o1 等 |
| Anthropic | Claude 系列 |
| Google | Gemini 系列 |
| DeepSeek | 兼容 OpenAI 格式 |
| Qwen（通义） | 兼容 OpenAI 格式 |
| OpenRouter | 聚合多家模型 |
| 自定义端点 | 兼容 OpenAI 格式的任何服务（含本地 Ollama） |
| 赞助商 Key | 预留位，未来有赞助商时启用 |

按场景推荐：引导式学习（强推理）→ Claude / GPT-4o / DeepSeek-R1；快速问答 → 轻量模型；本地隐私 → Ollama。

### Prompt/Context 工程

**Prompt 库是产品的核心资产**——学习设计被编码成 prompt，不是附属品。

运行时 context 由三层拼接而成：

| 层 | 内容 | 特点 |
|----|------|------|
| **AI 人格** | System prompt：苏格拉底式导师、POE 模式、永远不直接给答案 | 静态，所有概念共享 |
| **学习者状态** | 当前项目、概念、进度、代码状态 | 动态，由可视化界面自动注入 |
| **概念引导脚本** | 预设问题序列、常见错误映射、顿悟触发点 | 按概念组织，是核心资产 |

Prompt 库目录结构：

```
prompts/
├── system/                    # 通用 system prompt
│   ├── tutor-persona.md       # AI 导师人格设定
│   └── pedagogy-rules.md      # 教学规则（POE、不给答案等）
├── tiny-interpreter/          # 按项目组织
│   ├── context.md             # 项目整体背景
│   ├── concepts/              # 按概念组织引导脚本
│   └── diagnostics/           # 错误诊断映射
└── templates/                 # 可复用的 prompt 模板
```

## 技术约定

### 项目结构

```
first-principles-cs/
├── projects/           # 8 个核心系统
│   ├── language/       # tiny-interpreter, simple-compiler
│   ├── systems/        # mini-os, simple-fs
│   ├── data/           # storage-engine, tx-manager
│   └── distributed/    # consensus, dist-kv
├── web/                # 交互式学习 Web 应用
├── prompts/            # AI 引导 prompt 库（核心资产）
├── docs/               # 顶层文档（why, roadmap, projects, progress）
├── principles/         # 四大原则
├── courses/            # 六大课程模块
└── templates/          # 项目模板
```

### 国际化（i18n）约定

- 默认语言：中文（无后缀，如 `README.md`）
- 英文：`.en.md` 后缀（如 `README.en.md`）
- 其他语言：ISO 639-1 代码（`.ja.md`、`.ko.md` 等）
- 每个翻译文件顶部必须有语言切换器：`[中文](README.md) | [English](README.en.md)`
- 文档内部交叉引用指向同语言版本
- 详见 `docs/CONTRIBUTING.md`

### 四大核心原则

1. **接口与不变量** — 明确系统边界，定义必须始终成立的性质
2. **失败模型** — 识别所有可能的失败场景，设计容错机制
3. **验证优先** — 测试先行，用属性测试和故障注入验证不变量
4. **重构记录** — 持续简化实现，保持测试通过，记录设计演化

### AI 协作流程

1. 规格先行 → 2. AI 生成实现 → 3. 约束测试 → 4. 重构压复杂度

## 注意事项

- 这是学习产品，不是生产级系统。代码目标是**清晰**，不是高性能
- 每个项目都应该有"顿悟时刻"的设计——在关键概念处制造"啊哈"体验
- tiny-interpreter 的 learn/ 模式是模板，未来应推广到其他项目
- 不回避 AI 的帮助，关键是学习者要知道自己在做什么，能验证和诊断
