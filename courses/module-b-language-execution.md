# Module B: 语言与执行

## 模块目的与范围

本模块理解"程序如何运行"，回答三个核心问题：

1. **如何解释程序？** - 构建解释器，理解求值过程
2. **如何编译程序？** - 构建编译器，理解代码生成
3. **如何管理运行时？** - 理解内存管理、垃圾回收、并发

## 必学概念与不变量清单

### 1. 词法分析与语法分析

**核心概念**：
- 词法分析（Lexing）：将字符流转换为 token 流
- 语法分析（Parsing）：将 token 流转换为抽象语法树（AST）
- 上下文无关文法（CFG）：定义语言的语法规则

**关键不变量**：
- **词法正确性**：每个 token 都符合词法规则
- **语法正确性**：AST 符合语法规则
- **位置信息**：AST 保留源代码位置，用于错误报告

**理解标准**：
- 能为简单语言编写词法分析器
- 能为简单语言编写递归下降解析器
- 能识别语法歧义并消除

### 2. 求值与环境模型

**核心概念**：
- 求值（Evaluation）：计算表达式的值
- 环境（Environment）：变量名到值的映射
- 闭包（Closure）：函数 + 捕获的环境

**关键不变量**：
- **词法作用域**：变量查找遵循静态作用域规则
- **环境链**：内层环境可以访问外层环境的变量
- **闭包捕获**：闭包捕获定义时的环境，而不是调用时的环境

**理解标准**：
- 能实现环境模型
- 能解释闭包的行为
- 能识别动态作用域与词法作用域的区别

### 3. 类型系统

**核心概念**：
- 类型检查：在编译时或运行时检查类型错误
- 类型推导：自动推导表达式的类型
- 多态：同一代码适用于多种类型

**关键不变量**：
- **类型安全**：类型正确的程序不会出现类型错误
- **类型保持**：求值保持类型不变
- **进展性**：类型正确的程序要么是值，要么可以继续求值

**理解标准**：
- 能为简单语言实现类型检查器
- 能解释类型推导算法（如 Hindley-Milner）
- 能识别类型系统的权衡（静态 vs 动态，强类型 vs 弱类型）

### 4. 代码生成与优化

**核心概念**：
- 中间表示（IR）：介于源代码与机器码之间的表示
- 寄存器分配：将变量映射到寄存器
- 优化：常量折叠、死代码消除、内联

**关键不变量**：
- **语义保持**：优化不改变程序语义
- **寄存器约束**：寄存器数量有限，需要溢出到内存

**理解标准**：
- 能将 AST 转换为 IR
- 能实现简单的寄存器分配算法
- 能实现常量折叠等简单优化

### 5. 内存管理与垃圾回收

**核心概念**：
- 堆分配：动态分配内存
- 垃圾回收：自动回收不再使用的内存
- 引用计数 vs 标记清除 vs 复制回收

**关键不变量**：
- **内存安全**：不会访问已释放的内存
- **无内存泄漏**：不再使用的内存最终会被回收
- **可达性**：只有从根集可达的对象才会被保留

**理解标准**：
- 能实现简单的堆分配器
- 能实现标记清除垃圾回收器
- 能解释不同垃圾回收算法的权衡

## 标志性产物

### 1. Tiny Interpreter

**目标**：实现一个最小的 Lisp 风格解释器。

**核心特性**：
- 词法分析与语法分析
- 环境模型与闭包
- 递归与尾调用优化

**关键不变量**：
- 词法作用域
- 尾调用优化（尾递归不消耗栈空间）

**验收标准**：
- [ ] 能运行递归斐波那契
- [ ] 能正确处理闭包
- [ ] 能通过 100+ 单元测试
- [ ] 有完整的设计文档

**仓库**：[tiny-interpreter](https://github.com/first-principles-cs/tiny-interpreter)

### 2. Simple Compiler

**目标**：实现一个简单的编译器，将高级语言编译到字节码或汇编。

**核心特性**：
- 类型检查
- 寄存器分配
- 代码生成

**关键不变量**：
- 类型安全
- 内存安全

**验收标准**：
- [ ] 能编译简单的函数
- [ ] 能通过类型检查
- [ ] 能生成可执行代码
- [ ] 有完整的设计文档

**仓库**：[simple-compiler](https://github.com/first-principles-cs/simple-compiler)

## 验收标准

完成本模块后，你应该能够：

- [ ] 实现词法分析器与语法分析器
- [ ] 实现环境模型与闭包
- [ ] 实现类型检查器
- [ ] 实现代码生成器
- [ ] 实现简单的垃圾回收器
- [ ] 解释不同语言特性的权衡（动态 vs 静态类型，解释 vs 编译）

## 推荐项目顺序

1. **Tiny Interpreter** - 先理解解释器，因为它更简单
2. **Simple Compiler** - 再理解编译器，因为它涉及更多优化

## 参考资料

### 书籍

- **《程序设计的抽象思维》（SICP）** - Abelson & Sussman
  - 第 4 章：元循环求值器

- **《编译原理》（Dragon Book）** - Aho et al.
  - 经典的编译器教材

- **《类型和程序设计语言》（Types and Programming Languages）** - Benjamin Pierce
  - 类型系统的权威教材

### 论文

- **"Recursive Functions of Symbolic Expressions"** - John McCarthy (1960)
  - Lisp 的原始论文

- **"Principal Type-Schemes for Functional Programs"** - Damas & Milner (1982)
  - Hindley-Milner 类型推导算法

### 在线资源

- **Crafting Interpreters** - Bob Nystrom
  - 从零实现解释器的优秀教程

- **Stanford CS143: Compilers**
  - 编译器课程

## 与其他模块的关系

- **Module A (基础)**：使用计算模型理解求值过程
- **Module C (单机系统)**：编译器生成的代码运行在操作系统上
- **Module D (数据系统)**：数据库查询语言需要解析与优化
- **Module E (网络与分布式)**：分布式系统需要序列化与反序列化

---

下一步：学习 [Module C: 单机系统](./module-c-single-node-systems.md)。
